## 一些算法

### 迭代算法(iteration)

　　迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果（一个判断条件）。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。

### 递归算法(recursion)

　　表现为程序的自身调用，把一个大的复杂的问题层层转换为一个小的和原问题相似的问题来求解。

> https://blog.csdn.net/liuchaoxuan/article/details/79967578
>
> 　　套用别人说过的一句话“迭代是人，递归是神”。
>
> 　　递归实际上不断地深层调用函数，**直到函数有返回才会逐层的返回**，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止），所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。
>
> 　　迭代大部分时候需要人为的对问题进行剖析，将问题转变为一次次的迭代来逼近答案。迭代不像递归一样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图‘表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。
>
> 　　总之，递归算法从思想上更加贴近人们处理问题的思路，而且所处的思想层级算是高层（神），而迭代则更加偏向于底层（人），所以从执行效率上来讲，底层(迭代)往往比高层(递归)来的高，但高层(递归)却能提供更加抽象的服务，更加的简洁。
>
> 使用斐波那契序列的求法来说明其区别：
>
> ![](https://ftp.bmp.ovh/imgs/2019/10/5b1fa35a89766b24.jpg)

### 回溯法(flash back)

　　回溯法是一种试探性算法，从这一点上看，它很像穷举法。但它终究不是穷举法，回溯法是**有组织的进行穷举**，在试探过程中不断通过题设要求减少搜索空间，而这种减少不是一个一个解的减少，而是对搜索空间进行大规模剪枝，从而使得实际搜索空间远远小于问题的解空间。算法大都在“不得不”的情况 下才会使用，如果有别的算法，那它很有可能比回溯法高效，别忘了，回溯法是基于穷举的。回溯法适用于解排列组合类问题，也就是说目标解是从一个候选空间中选择出来的。

### 动态规划（Dynamic programming, DP）

#### 基本概念

**1. 多阶段决策问题**

如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。

各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果.

**2．动态规划问题中的术语**

**阶段：**把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。 

　　在前面的例子中，第一个阶段就是点A，而第二个阶段就是点A到点B，第三个阶段是点B到点C，而第四个阶段是点C到点D。

**状态：**状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点。在前面的例子中，第一个阶段有一个状态即A，而第二个阶段有两个状态B1和B2，第三个阶段是三个状态C1，C2和C3，而第四个阶段又是一个状态D。 

　　过程的状态通常可以用一个或一组数来描述，称为状态变量。一般，状态是离散的，但有时为了方便也将状态取成连续的。当然，在现实生活中，由于变量形式的限制，所有的状态都是离散的，但从分析的观点，有时将状态作为连续的处理将会有很大的好处。此外，状态可以有多个分量(多维情形)，因而用向量来代表；而且在每个阶段的状态维数可以不同。

　　当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为状态集合。

**无后效性：**我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。

**决策：**一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。

　　决策变量的范围称为允许**决策集合**。

**策略：**由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。允许策略

　　<u>动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。</u>不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。

#### 分类：

* 线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；

* 区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；

* 树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；

* 背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（[同济](https://baike.baidu.com/item/同济/7707206)ACM第1132题）等；

应用实例：[最短路径](https://baike.baidu.com/item/最短路径)问题 ，[项目管理](https://baike.baidu.com/item/项目管理)，网络流优化等；

**大多数动态规划问题都能被归类成两种类型：**

**优化问题**和**组合问题**

* 优化问题希望你选择一个可行的解决方案，以便最小化或最大化所需函数的值。

* 组合问题希望你弄清楚做某事方案的数量或某些事件发生的概率。